{"filter":false,"title":"README.md","tooltip":"/README.md","undoManager":{"mark":0,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":475,"column":0},"action":"remove","lines":["# techstar.js","","Techstar AI is a machine-learning framework for Node.js. It supports **multi-label classification**, **online learning**, and **real-time classification**. Therefore, it is especially suited for natural language understanding in dialog systems and chat-bots.","","Techstar AI is in an \"alpha\" state - some parts are working (see this readme), but some parts are missing or not tested. Contributions are welcome. ","","Techstar AI currently runs on Node.js 0.12 and later versions.","","## Installation","","\tnpm install Techstar AI","","## Demos","","You can run the demos from this project: [Techstar AI-demo](https://github.com/erelsgl/Techstar AI-demo).","","**Table of Contents**  *generated with [DocToc](http://doctoc.herokuapp.com/)*","","- [Binary Classification](#binary-classification)","\t- [Batch Learning - learn from an array of input-output pairs:](#batch-learning---learn-from-an-array-of-input-output-pairs)","\t- [Online Learning](#online-learning)","\t- [Binding](#binding)","\t- [Explanations](#explanations)","\t- [Other Binary Classifiers](#other-binary-classifiers)","- [Multi-Label Classification](#multi-label-classification)","\t- [Other Multi-label classifiers](#other-multi-label-classifiers)","- [Feature engineering](#feature-engineering)","\t- [Feature extraction - converting an input sample into feature-value pairs:](#feature-extraction---converting-an-input-sample-into-feature-value-pairs)","\t- [Input Normalization](#input-normalization)","\t- [Feature lookup table - convert custom features to integer features](#feature-lookup-table---convert-custom-features-to-integer-features)","- [Serialization](#serialization)","- [Cross-validation](#cross-validation)","- [Back-classification (aka Generation)](#back-classification-aka-generation)","- [SVM wrappers](#svm-wrappers)","- [Undocumented featuers](#undocumented-featuers)","- [Contributions](#contributions)","- [License](#license)","","## Binary Classification","","### Batch Learning - learn from an array of input-output pairs:","","```js","var TechstarAI = require('TechstarAI');","","var colorClassifier = new TechstarAI.classifiers.NeuralNetwork();","","colorClassifier.trainBatch([","\t{input: { r: 0.03, g: 0.7, b: 0.5 }, output: 0},  // black","\t{input: { r: 0.16, g: 0.09, b: 0.2 }, output: 1}, // white","\t{input: { r: 0.5, g: 0.5, b: 1.0 }, output: 1}   // white","\t]);","","console.log(colorClassifier.classify({ r: 1, g: 0.4, b: 0 }));  // 0.99 - almost white","```","","Credit: this example uses [brain.js, by Heather Arthur](https://github.com/harthur/brain).","","","### Online Learning","```js","var birdClassifier = new Techstar AI.classifiers.Winnow({","\tdefault_positive_weight: 1,","\tdefault_negative_weight: 1,","\tthreshold: 0","});","","birdClassifier.trainOnline({'wings': 1, 'flight': 1, 'beak': 1, 'eagle': 1}, 1);  // eagle is a bird (1)","birdClassifier.trainOnline({'wings': 0, 'flight': 0, 'beak': 0, 'dog': 1}, 0);    // dog is not a bird (0)","console.dir(birdClassifier.classify({'wings': 1, 'flight': 0, 'beak': 0.5, 'penguin':1})); // initially, penguin is mistakenly classified as 0 - \"not a bird\"","console.dir(birdClassifier.classify({'wings': 1, 'flight': 0, 'beak': 0.5, 'penguin':1}, /*explanation level=*/4)); // why? because it does not fly.","","birdClassifier.trainOnline({'wings': 1, 'flight': 0, 'beak': 1, 'penguin':1}, 1);  // learn that penguin is a bird, although it doesn't fly ","birdClassifier.trainOnline({'wings': 0, 'flight': 1, 'beak': 0, 'bat': 1}, 0);     // learn that bat is not a bird, although it does fly","console.dir(birdClassifier.classify({'wings': 1, 'flight': 0, 'beak': 1, 'chicken': 1})); // now, chicken is correctly classified as a bird, although it does not fly.  ","console.dir(birdClassifier.classify({'wings': 1, 'flight': 0, 'beak': 1, 'chicken': 1}, /*explanation level=*/4)); // why?  because it has wings and beak.","```","","Credit: this example uses Modified Balanced Margin Winnow ([Carvalho and Cohen, 2006](http://www.citeulike.org/user/erelsegal-halevi/article/2243777)). ","","The \"explanation\" feature is explained below.","","","### Binding","","Using Javascript's binding capabilities, it is possible to create custom classes, which are made of existing classes and pre-specified parameters:","```js","var MyWinnow = TechstarAI.classifiers.Winnow.bind(0, {","\tdefault_positive_weight: 1,","\tdefault_negative_weight: 1,","\tthreshold: 0","});","","var birdClassifier = new MyWinnow();","...","// continue as above","```","","### Explanations","","Some classifiers can return \"explanations\" - additional information that explains how the classification result has been derived: ","","```js","var colorClassifier = new TechstarAI.classifiers.Bayesian();","","colorClassifier.trainBatch([","\t{input: { r: 0.03, g: 0.7, b: 0.5 }, output: 'black'}, ","\t{input: { r: 0.16, g: 0.09, b: 0.2 }, output: 'white'},","\t{input: { r: 0.5, g: 0.5, b: 1.0 }, output: 'white'},","\t]);","","console.log(colorClassifier.classify({ r: 1, g: 0.4, b: 0 }, ","\t\t/* explanation level = */1));","```","Credit: this example uses code from [classifier.js, by Heather Arthur](https://github.com/harthur/classifier).","","The explanation feature is experimental and is supported differently for different classifiers. For example, for the Bayesian classifier it returns the probabilities for each category:","","```js","{ classes: 'white',","\texplanation: [ 'white: 0.0621402182289608', 'black: 0.031460948468170505' ] }","```","","While for the winnow classifier it returns the relevance (feature-value times feature-weight) for each feature: ","","```js","{ classification: 1,","\texplanation: [ 'bias+1.12', 'r+1.08', 'g+0.25', 'b+0.00' ] }","```","","WARNING: The internal format of the explanations might change without notice. The explanations should be used for presentation purposes only (and not, for example, for extracting the actual numbers). ","","### Other Binary Classifiers","","In addition to Winnow and NeuralNetwork, version 0.2 includes the following binary classifiers:","","* Bayesian - uses [classifier.js, by Heather Arthur](https://github.com/harthur/classifier). ","* Perceptron - Loosely based on [perceptron.js, by John Chesley](https://github.com/chesles/perceptron).","* SVM - uses [svm.js, by Andrej Karpathy](https://github.com/karpathy/svmjs). ","* Linear SVM - wrappers around SVM-Perf and Lib-Linear (see below).","* Decision Tree - based on [node-decision-tree-id3 by Ankit Kuwadekar](https://github.com/bugless/nodejs-decision-tree-id3) or [ID3-Decision-Tree by Will Kurt](https://github.com/willkurt/ID3-Decision-Tree).","","This library is still under construction, and not all features work for all classifiers. For a full list of the features that do work, see the \"test\" folder. ","","","## Multi-Label Classification","","In binary classification, the output is 0 or 1;","","In multi-label classification, the output is a set of zero or more labels.","","```js","var MyWinnow = TechstarAI.classifiers.Winnow.bind(0, {retrain_count: 10});","","var intentClassifier = new TechstarAI.classifiers.multilabel.BinaryRelevance({","\tbinaryClassifierType: MyWinnow","});","","intentClassifier.trainBatch([","\t{input: {I:1,want:1,an:1,apple:1}, output: \"APPLE\"},","\t{input: {I:1,want:1,a:1,banana:1}, output: \"BANANA\"},","\t{input: {I:1,want:1,chips:1}, output: \"CHIPS\"}","\t]);","","console.dir(intentClassifier.classify({I:1,want:1,an:1,apple:1,and:1,a:1,banana:1}));  // ['APPLE','BANANA']","```","","### Other Multi-label classifiers","","In addition to BinaryRelevance, version 0.2 includes the following multi-label classifier types (see the multilabel folder):","","* Cross-Lingual Language Model Classifier (based on [Anton Leusky and David Traum, 2008](http://www.citeulike.org/user/erelsegal-halevi/article/12540655))","* HOMER - Hierarchy Of Multi-label classifiERs (based on [Tsoumakas et al., 2007](http://www.citeulike.org/user/erelsegal-halevi/article/3170786))","* Meta-Labeler (based on [Lei Tang, Suju Rajan, Vijay K. Narayanan, 2009](http://www.citeulike.org/user/erelsegal-halevi/article/4860265)) ","* Joint identification and segmentation (based on [Fabrizio Morbini, Kenji Sagae, 2011](http://www.citeulike.org/user/erelsegal-halevi/article/10259046))","* Passive-Aggressive (based on [Koby Crammer, Ofer Dekel, Joseph Keshet, Shai Shalev-Shwartz, Yoram Singer, 2006](http://www.citeulike.org/user/erelsegal-halevi/article/5960770))","* Threshold Classifier (converting multi-class classifier to multi-label classifier by finding the best appropriate threshold)","","This library is still under construction, and not all features work for all classifiers. For a full list of the features that do work, see the \"test\" folder. ","","## Feature engineering","","### Feature extraction - converting an input sample into feature-value pairs:","","```js","// First, define our base classifier type (a multi-label classifier based on winnow):","var TextClassifier = TechstarAI.classifiers.multilabel.BinaryRelevance.bind(0, {","\tbinaryClassifierType: TechstarAI.classifiers.Winnow.bind(0, {retrain_count: 10})","});","","// Now define our feature extractor - a function that takes a sample and adds features to a given features set:","var WordExtractor = function(input, features) {","\tinput.split(\" \").forEach(function(word) {","\t\tfeatures[word]=1;","\t});","};","","// Initialize a classifier with the base classifier type and the feature extractor:","var intentClassifier = new TechstarAI.classifiers.EnhancedClassifier({","\tclassifierType: TextClassifier,","\tfeatureExtractor: WordExtractor","});","","// Train and test:","intentClassifier.trainBatch([","\t{input: \"I want an apple\", output: \"apl\"},","\t{input: \"I want a banana\", output: \"bnn\"},","\t{input: \"I want chips\", output:    \"cps\"},","\t]);","","console.dir(intentClassifier.classify(\"I want an apple and a banana\"));  // ['apl','bnn']","console.dir(intentClassifier.classify(\"I WANT AN APPLE AND A BANANA\"));  // []","```","","As you can see from the last example, by default feature extraction is case-sensitive. ","We will take care of this in the next example.","","Instead of defining your own feature extractor, you can use those already bundled with Techstar AI:","","```js","TechstarAI.features.NGramsOfWords","TechstarAI.features.NGramsOfLetters","TechstarAI.features.HypernymExtractor","```","","You can also make 'featureExtractor' an array of several feature extractors, that will be executed in the order you include them.","","### Input Normalization","","```js","//Initialize a classifier with a feature extractor and a case normalizer:","intentClassifier = new TechstarAI.classifiers.EnhancedClassifier({","\tclassifierType: TextClassifier,  // same as in previous example","\tnormalizer: TechstarAI.features.LowerCaseNormalizer,","\tfeatureExtractor: WordExtractor  // same as in previous example","});","","//Train and test:","intentClassifier.trainBatch([","\t{input: \"I want an apple\", output: \"apl\"},","\t{input: \"I want a banana\", output: \"bnn\"},","\t{input: \"I want chips\", output: \"cps\"},","\t]);","","console.dir(intentClassifier.classify(\"I want an apple and a banana\"));  // ['apl','bnn']","console.dir(intentClassifier.classify(\"I WANT AN APPLE AND A BANANA\"));  // ['apl','bnn'] ","```","","Of course you can use any other function as an input normalizer. For example, if you know how to write a spell-checker, you can create a normalizer that corrects typos in the input.","","You can also make 'normalizer' an array of several normalizers. These will be executed in the order you include them.","","### Feature lookup table - convert custom features to integer features","","This example uses the quadratic SVM implementation [svm.js, by Andrej Karpathy](https://github.com/karpathy/svmjs). ","This SVM (like most SVM implementations) works with integer features, so we need a way to convert our string-based features to integers.","","```js","var Techstar AI = require('TechstarAI');","","// First, define our base classifier type (a multi-label classifier based on svm.js):","var TextClassifier = TechstarAI.classifiers.multilabel.BinaryRelevance.bind(0, {","\tbinaryClassifierType: TechstarAI.classifiers.SvmJs.bind(0, {C: 1.0})","});","","// Initialize a classifier with a feature extractor and a lookup table:","var intentClassifier = new TechstarAI.classifiers.EnhancedClassifier({","\tclassifierType: TextClassifier,","\tfeatureExtractor: TechstarAI.features.NGramsOfWords(1),  // each word (\"1-gram\") is a feature  ","\tfeatureLookupTable: new TechstarAI.features.FeatureLookupTable()","});","","// Train and test:","intentClassifier.trainBatch([","\t{input: \"I want an apple\", output: \"apl\"},","\t{input: \"I want a banana\", output: \"bnn\"},","\t{input: \"I want chips\", output: \"cps\"},","\t]);","","console.dir(intentClassifier.classify(\"I want an apple and a banana\"));  // ['apl','bnn']","```","","The FeatureLookupTable takes care of the numbers, while you may continue to work with texts! ","","## Serialization","","Say you want to train a classifier on your home computer, and use it on a remote server. To do this, you should somehow convert the trained classifier to a string, send the string to the remote server, and deserialize it there.","","You can do this with the \"serialization.js\" package:","","\tnpm install serialization","\t","On your home machine, do the following:","","```js","var serialize = require('serialization');","","// First, define a function that creates a fresh  (untrained) classifier.","// This code should be stand-alone - it should include all the 'require' statements","//   required for creating the classifier.","function newClassifierFunction() {","\tvar TechstarAI = require('Techstar AI');","\tvar TextClassifier = TechstarAI.classifiers.multilabel.BinaryRelevance.bind(0, {","\t\tbinaryClassifierType: TechstarAI.classifiers.Winnow.bind(0, {retrain_count: 10})","\t});","","\tvar WordExtractor = function(input, features) {","\t\tinput.split(\" \").forEach(function(word) {","\t\t\tfeatures[word]=1;","\t\t});","\t};","\t","\t// Initialize a classifier with a feature extractor:","\treturn new TechstarAI.classifiers.EnhancedClassifier({","\t\tclassifierType: TextClassifier,","\t\tfeatureExtractor: WordExtractor,","\t\tpastTrainingSamples: [], // to enable retraining","\t});","}","","// Use the above function for creating a new classifier:","var intentClassifier = newClassifierFunction();","","// Train and test:","var dataset = [","\t{input: \"I want an apple\", output: \"apl\"},","\t{input: \"I want a banana\", output: \"bnn\"},","\t{input: \"I want chips\", output: \"cps\"},","\t];","intentClassifier.trainBatch(dataset);","","console.log(\"Original classifier:\");","intentClassifier.classifyAndLog(\"I want an apple and a banana\");  // ['apl','bnn']","intentClassifier.trainOnline(\"I want a doughnut\", \"dnt\");","intentClassifier.classifyAndLog(\"I want chips and a doughnut\");  // ['cps','dnt']","intentClassifier.retrain();","intentClassifier.classifyAndLog(\"I want an apple and a banana\");  // ['apl','bnn']","intentClassifier.classifyAndLog(\"I want chips and a doughnut\");  // ['cps','dnt']","","// Serialize the classifier (convert it to a string)","var intentClassifierString = serialize.toString(intentClassifier, newClassifierFunction);","","// Save the string to a file, and send it to a remote server.","```","","On the remote server, do the following:","","```js","// retrieve the string from a file and then:","","var intentClassifierCopy = serialize.fromString(intentClassifierString, __dirname);","","console.log(\"Deserialized classifier:\");","intentClassifierCopy.classifyAndLog(\"I want an apple and a banana\");  // ['apl','bnn']","intentClassifierCopy.classifyAndLog(\"I want chips and a doughnut\");  // ['cps','dnt']","intentClassifierCopy.trainOnline(\"I want an elm tree\", \"elm\");","intentClassifierCopy.classifyAndLog(\"I want doughnut and elm tree\");  // ['dnt','elm']","```","","CAUTION: Serialization was not tested for all possible combinations of classifiers and enhancements. Test well before use!","","## Cross-validation","","```js","// create a dataset with a lot of input-output pairs:","var dataset = [ ... ];","","// Decide how many folds you want in your   k-fold cross-validation:","var numOfFolds = 5;","","// Define the type of classifier that you want to test:","var IntentClassifier = TechstarAI.classifiers.EnhancedClassifier.bind(0, {","\tclassifierType: TechstarAI.classifiers.multilabel.BinaryRelevance.bind(0, {","\t\tbinaryClassifierType: TechstarAI.classifiers.Winnow.bind(0, {retrain_count: 10})","\t}),","\tfeatureExtractor: TechstarAI.features.NGramsOfWords(1),","});","","var microAverage = new TechstarAI.utils.PrecisionRecall();","var macroAverage = new TechstarAI.utils.PrecisionRecall();","","Techstar AI.utils.partitions.partitions(dataset, numOfFolds, function(trainSet, testSet) {","\tconsole.log(\"Training on \"+trainSet.length+\" samples, testing on \"+testSet.length+\" samples\");","\tvar classifier = new IntentClassifier();","\tclassifier.trainBatch(trainSet);","\tTechstar AI.utils.test(classifier, testSet, /* verbosity = */0,","\t\tmicroAverage, macroAverage);","});","","macroAverage.calculateMacroAverageStats(numOfFolds);","console.log(\"\\n\\nMACRO AVERAGE:\"); console.dir(macroAverage.fullStats());","","microAverage.calculateStats();","console.log(\"\\n\\nMICRO AVERAGE:\"); console.dir(microAverage.fullStats());","```","","## Back-classification (aka Generation)","","Use this option to get the list of all samples with a given class.","","```js","var intentClassifier = new TechstarAI.classifiers.EnhancedClassifier({","\tclassifierType: TechstarAI.classifiers.multilabel.BinaryRelevance.bind(0, {","\t\tbinaryClassifierType: TechstarAI.classifiers.Winnow.bind(0, {retrain_count: 10})","\t}),","\tfeatureExtractor: TechstarAI.features.NGramsOfWords(1),","\tpastTrainingSamples: [],","});","","// Train and test:","intentClassifier.trainBatch([","\t{input: \"I want an apple\", output: \"apl\"},","\t{input: \"I want a banana\", output: \"bnn\"},","\t{input: \"I really want an apple\", output: \"apl\"},","\t{input: \"I want a banana very much\", output: \"bnn\"},","\t]);","","console.dir(intentClassifier.backClassify(\"apl\"));  // [ 'I want an apple', 'I really want an apple' ]","```","","## SVM wrappers","","The native svm.js implementation takes a lot of time to train -  quadratic in the number of training samples. ","There are two common packages that can be trained in time linear in the number of training samples. They are:","","* [SVM-Perf](http://www.cs.cornell.edu/people/tj/svm_light/svm_perf.html) - by Thorsten Joachims;","* [LibLinear](http://www.csie.ntu.edu.tw/~cjlin/liblinear) - Fan, Chang, Hsieh, Wang and Lin.","","The Techstar AI.js package provides wrappers for these implementations. ","In order to use the wrappers, you must have the binary file used for training in your path, that is:","","* **svm\\_perf\\_learn** - from [SVM-Perf](http://www.cs.cornell.edu/people/tj/svm_light/svm_perf.html).","* **liblinear\\_train** - from [LibLinear](http://www.csie.ntu.edu.tw/~cjlin/liblinear).","","Once you have any one of these installed, you can use the corresponding classifier instead of any binary classifier","used in the previous demos, as long as you have a feature-lookup-table. For example, with SvmPerf:","","```js","var intentClassifier = new TechstarAI.classifiers.EnhancedClassifier({","\tclassifierType: TechstarAI.classifiers.multilabel.BinaryRelevance.bind(0, {","\t\tbinaryClassifierType: TechstarAI.classifiers.SvmPerf.bind(0, \t{","\t\t\tlearn_args: \"-c 20.0\" ","\t\t})","\t}),","\tfeatureExtractor: TechstarAI.features.NGramsOfWords(1),","\tfeatureLookupTable: new TechstarAI.features.FeatureLookupTable()","});","```","","and similarly with SvmLinear.","","See the files classifiers/svm/SvmPerf.js and classifiers/svm/SvmLinear.js for a documentation of the options.","","","## Undocumented featuers","","Some advanced features are working but not documented yet. If you need any of them, open an issue and I will try to document them.","","* Custom input normalization, based on regular expressions.","* Input segmentation for multi-label classification - both manual (with regular expressions) and automatic.","* Feature extraction for model adaptation.","* Spell-checker features. ","* Hypernym features.","* Classification based on a cross-lingual language model.","* Format conversion - ARFF, JSON, svm-light, TSV.","","## License","","LGPL","","## Contributions","","Code contributions are welcome. Reasonable pull requests, with appropriate documentation and unit-tests, will be accepted.","","Do you like Techstar AI? Remember that you can star it :-)",""],"id":2},{"start":{"row":0,"column":0},"end":{"row":87,"column":0},"action":"insert","lines":["# Нейроны сүлжээ ашиглан машин сургах ","","Хүний хөгжлийн явцад хүний тархины эд эсүүд үүсэн бий болдог. Эдгээр эсүүдээс нейрон буюу мэдрэлийн эс нь **анхдагч бүрдүүлэгч эс** юм. Мэдрэлийн эс нь тэмтрүүлүүдээрээ дамжуулж цочрол буюу дохиог хүлээн авна. Мэдрэлийн эс цочролыг хүлээн авсны дараа цочрол боловсруулагдаж сэрэл үүснэ. Ингэснээр бусад мэдрэлийн эсэд хүрэх чадвартай харьцангуй урт аксоноор дамжин, аксоны гарцаар гадагшилж мэдрэлийн эсийг орхин гарна. Ингэж цочрол нь бусад нейронууд болон мэдрэлийн судалд дамждаг. ","","Биологийн үндэслэл дээр үндэслэн хиймэл нейроны сүлжээний санааг 1943 онд МакКуллош, Питт нар нээжээ. 1986 онд Румэлхарт, МакКелланд нар Англи хэлний өнгөрсөн цагийн хувиллын хэлбэрүүдийг нейроны сүлжээгээр туршиж үзжээ. ","","Түүнээс хойш үгийн хувиллыг нейроны сүлжээгээр гүйцэтгэх, үгийн бүтцийг нейроны сүлжээгээр тодорхойлох оролдлого олон хийгджээ. Компьютер олон үйлдлийг хүнээс харьцангуй хурдан хийдэг ч компьютерийн шийдэж чадахгүй олон асуудлыг балчир хүүхэд ч хийж чадна. Жишээлбэл, хонь ямаа хоёрыг хүүхэд ялгаж чадна. Хүний тархины биологийн нейроны сүлжээг дуурайлган хиймэл нейроны сүлжээг компьютерт дүрслэхийг **Хиймэл нейроны сүлжээ** гэж нэрлэдэг. ","","Энгийн алхамуудтай, хийх гэж байгаа үйлдлүүд нь тодорхой, төлөв нь тогтвортой алгоритмтай програмд нейроны сүлжээ ашиглах шаардлагагүй. Тодорхой тооны алхмуудаар илэрхийлэх боломжгүй, тогтворгүй төлөвтэй асуудлыг шийдвэрлэхэд нейроны сүлжээ тохиромжтой. Үүнд, дүрс таних, ангилах, өгөгдлийн агуулах гэх мэтийн асуудлууд орно. Нейроны сүлжээг ашигласнаар уламжлалт програмчлалын алгоритмыг бодвол програмын багахан хэмжээний кодчилол шаардагддаг. ","","Мэдрэлээр дамжсан дохио нь аналог дохио байдаг. Мэдрэл нь аналоги дохио буюу цочролыг тэмтрүүлүүдээр хүлээн авна. Учир нь дохио бол аналоги, сигнал бүр өөр өөр хүчдэлтэй байна. Хэрэв хүчдэл нь тодорхой хязгаарт байвал мэдрэлийн эсэд сэрэл бий болно. Энэ үед сэрэл боловсруулагдаж өөрчлөгдсөн аналоги дохиог (цочролыг) бусад мэдрэлүүд рүү тараана. Оролт гаралтын мужийг мэдрэлийн эсийн холбоос гэнэ. Мэдрэлийн эс нь сэрэл үүсэх эсэхээс хамааран **оюун дүгнэлт** буюу гаралт гаргана. ","","Нейроны сүлжээ нь удирдамжтай эсэхээр өөрийгөө зохион байгуулагч дүрс, олон чиглэлт сүлжээ гэж ангилагддаг боловч хамгийн өргөн ашиглагддаг нь олон давхрагат, нэг чиглэлийн сүлжээ юм. Энэ сүлжээ нь олон түвшний давхрагуудтай бөгөөд эхнийх нь оролтын, эцсийнх нь гаралтын давхарга юм. Оролт гаралтын хоорондох давхрагуудыг нууц давхрагууд гэнэ. ","","Бие даасан мэдрэлүүд нь нейроны сүлжээг үүсгэх ба хоорондоо мэдрэлийн холбоосуудаар холбогдоно. Энэ холбоосууд нь бие биедээ цорчрол өгөх замаар мэдээллийг боловсруулдаг. Холбоос бүр өөрийн гэсэн холбоосын жинтэй байдаг. Хэрэв хоёр мэдрэлийн хооронд холбоос байхгүй бол тэдгээрийн хооронд холбоосын жин тэг байна. Эдгээр жингүүд нь нейроны сүлжээний гаралтыг тодорхойлдог. ","","Суралцах гэдэг нь холбоосын жингүүдийг тодорхойлох процесс юм. Ихэнх суралцах алгоритмууд эхлээд холбоосын жингүүдийг санамсаргүйгээр тогтоодог. Дараа нь нейроны сүлжээний зохистой байдлыг шалгаж, шалгалтын үр дүнд үндэслэн холбоосын жинг тохируулдаг. Энэ процесс нь шалгалтын үр дүн зөвшөөрөгдөх хэмжээнд хүртэл хийгдэнэ. ","","Нейроны сүлжээг сургах хоёр үндсэн арга байдаг. Үүнд: ","- Удирдамжтай сургах арга ","- Удирдамжгүй сургах арга ","","**Удирдамжтай сургах арга нь** урьдчилан тодорхойлсон гаралтууд бүхий жишээ өгөгдлийн олонлогоор нейроны сүлжээг сургадаг. Энэ арга нейроны сүлжээ сургах хамгийн түгээмэл хэлбэр юм. Жишээ өгөгдлийг нейроны сүлжээгээр оруулж, гаралтын эс дээр ирсэн үр дүнг урьдчилан тодорхойлсон гаралттай харьцуулж, хүлээн зөвшөөрөгдөх алдааны түвшинд хүртэл эсүүдийн холбоосын жинг сайжруулах үйлдлийг олон дахин давтдаг. Давталт бүр дээр бүх жишээгээр сургана. Энэ төрлийн аргуудаас өргөн хэрэглэдэг нь **фидфорвард бакпропагашн** алгоритм юм. ","","Нейроны сүлжээг сургах, ашиглахад дараах хоёр асуудал байдаг. ","Үүнд: ","**1. Суралцах дүрэм** ","","Удирдамжтай сургах үед алдааны түвшинг тодорхойлохдоо хоёр зүйлийг авч үзнэ. ","Нэгдүгээрт, суралцагч олонлогийн элемент бүрийн алдаа. Хоёрдугаарт, жишээ бүрийн хувьд суралцагч олонлогийн элемент бүрийн дундаж квадрат алдаа. Гаралтын алдаа нь урьдчилан тооцоолсон гаралт болон суралцагч олонлогийн элемент дээр тооцоолсон гаралт хоёрын зөрүү юм. Сургалтын процесс нь нейроны сүлжээ хүссэн үр дүнг гаргадаг болтол эсийн холбоосын жинг өөрчлөх үйл ажиллагаа юм. Хоёр төрлийн сургалтын дүрэм байдаг. Үүнд: ","","**Хеббийн дүрэм.** ","Энэ дүрмийг Дональд Хебб анх боловсруулж, удирдамжгүй сургалтанд хамгийн их ашиглагддаг арга юм. Удирдамжгүй сургах алгоритмд гаралт зөв буруугийн тухай яригдахгүй. Зөвхөн оролтын өгөгдлийг бүлэглэх зорилготой. Иймээс алдааны түвшинг тооцохгүй. ","","**Дельта дүрэм.** ","Энэ дүрмийг удирдамжтай сургах алгоритмд ашигладаг. Нейроны сүлжээнд өгөгдөл оруулан, урьдчилан тооцоолсон гаралт руу илүү нарийвчлалтай дөхсөн гаралт олохын тулд эсүүдийн холбоосын жинг өөрчилж тохируулна. Суралцах функцийн нэг чухал бүрэлдэхүүн хэсэг бол алдааны түвшин юм. Алдааны түвшин нь урьдчилан тооцоолсон алдаа болон сүлжээнээс гарч байгаа үр дүн хоёрын харьцаа байдаг. Алгебрийн аргаар Дельта дүрмийг дараах байдлаар тодорхойлно. ","","**2. Идэвхжүүлэлтийн функц** ","Ихэнх нейроны сүлжээ эсүүд дээрх утгыг идэвхижүүлэлтийн функцээр дамжуулдаг. Идэвхижүүлэлтийн функц нь сүлжээний гаралтыг тодорхой хязгаар дотор өсгөж бууруулна. Ер нь давхрага бүр дээр өөр өөр идэвхижүүлэлтийн функц ашиглаж болно. ","Гурван төрлийн идэвхижүүлэлтийн функц байдаг. Үүнд: ","","**Сигмоид.** ","Функцийн утга нь 0-с 1 завсарт орших ба график нь S үсэг шиг хэлбэртэй байна. Энэ функц нь зөвхөн эерэг тоо буцаадаг. Хэрэв сүлжээний эсийн утгад сөрөг тоо шаардлагатай бол энэ функц тохиромжгүй. ","","**Гипербаллог тангенс.** ","Функцийн утга -1 +1 завсарт утга авна. Энэ нь сигмоид функцийг бодвол илүү нийлмэл бүтэцтэй бөгөөд сигмоид функцийн эсрэг сөрөг утга авах боломжтой өргөтгөсөн хэлбэр гэж ойлгож болно. ","","**Шугаман.** ","Энэ функц нь үнэндээ идэвхижүүлэлтийн функцгүй гэсэн үг. Энэ функцийг бараг ашиглахгүй. Орсон зүйлийг тэр чигээр нь гаргадаг. ","","**Фидфорвард бакпропагашн нейроны сүлжээ** ","","Удирдамжтай сургахад ашигладаг, сүлжээг сургахдаа Дельта дүрэм ашигладаг. Сургалтын алдааг дундаж квадрат алдаагаар тооцоолдог, эсүүд дээрх гаралтыг өсгөж бууруулахдаа ихэвчлэн сигмоид идэвхжүүлэлтийн функц ашигладаг олон давхрагат нэг чиглэлийн сүлжээг **фидфорвард бакпропагашн нейроны сүлжээ** гэнэ. ","","Энэ сүлжээг сургахдаа дараах алхмуудаас тогтоно. Үүнд: ","","- Сургалтын өгөгдлийг нейроны сүлжээгээр оруулахад гаралтын эс дээр үр дүн ирнэ. Энэ алхмыг фидфорвард алгоритм гэнэ. ","- Хэрэв гаралтын эс дээр ирсэн үр дүн хүлээн зөвшөөрөгдөх алдааны түвшинд хүрээгүй байвал гаралтын эсийн үр дүн болон урьдчилан тодорхойлогдсон гаралтын зөрүүгээс хамаарч эсүүдийн холбоосын жинг сайжруулах. Энэ алхмыг бакпропагашн алгоритм гэнэ. ","- Гаралтын эс дээр ирсэн үр дүн хүлээн зөвшөөрөгдөх алдааны түвшинд хүртэл дээрх алхмуудыг олон дахин давтана. Харин энэ сүлжээг ашиглаж үр дүн гаргахдаа зөвхөн фидфорвард алгоритм ашиглана. ","","**Фидфорвард алгоритм** ","Энэ нь оролтоос гаралтын давхрага руу чиглэсэн байдлаар нэг чиглэлд энгийн аргаар хийгдэнэ. Эс бүрийн үр дүн нь тухайн эс рүү орсон холбоосын жин ба оролтын утга хоёрын үржвэрийн нийлбэр дээр хязгаарыг нэмсэн утгыг идэвхижүүлэлтийн функцээр оруулахад гарна. Фидфорвард алгоритмд n-р нууц давхрагын үр дүн (n+1)-р нууц давхрагын оролт болно. Сүүлийн нууц давхрагын үр дүн гаралтын давхрагын оролт болно. ","","**Бакпропагашн алгоритм** ","Энэ нь гаралтын эсийн үр дүн болон урьдчилан тодорхойлогдсон гаралтын зөрүүгээс хамааран, гаралтаас оролтын давхрага руу чиглэсэн байдлаар эсүүдийн холбоосын жинг сайжруулдаг. Сүлжээ нь оролтын давхрага, нууц давхрага, гаралтын давхрагаас бүрдэнэ.  гаралтын зөрүүнээс хамааран холбоосын жинг өөрчлөх үйл ажиллагаа нь гаралтын давхрагаас эхлэн нууц давхрагуудыг холбоосын жингүүдийг өөрчилнө. Иймээс гаралтын давхрага дээрх эсүүдийн холбоосын жинг өөрчлөх, нууц давхрага дээрх эсүүдийн холбоосын жинг өөрчлөх гэсэн хоёр алхамтай байна. ","","Сүлжээг байгуулах үед дараах шийдэх асуудлууд гардаг. Үүнд:",""," **- Нууц давхрагын тоо.** Хоёр нууц давхрагатай нейроны сүлжээ ямар ч хэлбэрийн функцийг илэрхийлж чадна. Одоогоор хоёроос дээш тооны нууц давхрагатай нейроны сүлжээг ашиглах онолын шаардлага байхгүй. "," ","**- Давхрагууд дээрх эсийн тоо.** Нууц давхрагууд дээрх эсийн тоог тодорхойлох нь нейроны сүлжээний ерөнхий архитектурыг тодорхойлоход чухал үүрэгтэй. Хэдийгээр эдгээр нууц давхрагууд нь гадаад орчинтой харьцахгүй боловч эдгээр нь эцсийн үр дүнд гол нөлөө үзүүлдэг. Нууц давхрагууд дээр хэтэрхий цөөхөн эс байрлуулбал эцсийн үр дүн буруу гарах магадлалтай байдаг. Нууц давхрагууд дээр хэтэрхий олон эс байрлуулбал дараах хүндрэлүүд гарах магадлалтай. Эхний тулгарах хүндрэл нь илүүдэлт. Их хэмжээний мэдээлэл боловсруулах чадвартай нейроны сүлжээ байхад хязгаарлагдмал тооны мэдээлэл агуулах сургалтын олонлогоор нууц давхрагууд дээрх мэдрэлийн эсүүдийг бүгдийг сургахад хангалтгүй. Хоёрдугаарт, сургалтын өгөгдлөл хангалттай байхад тохиолдоно. Хэтэрхий олон эс нууц давхрагууд дээр байвал сүлжээг сургах хугацааг ихэсгэдэг. Сургах хугацаа ихэссэнээр нейроны сүлжээг хангалттай сургах боломжгүй болдог. Нууц давхрагууд дээрх эсийн тоог зөв тодорхойлох хэд хэдэн дүрэм байдаг. Үүнд:","","o Нууц давхрага дээрх эсийн тоо нь оролтын давхрага дээрх эс, гаралтын давхрага дээрх эсийн тоо хоёрын хооронд байх ёстой. ","","o Нууц давхрага дээрх эсийн тоо нь оролтын давхрага дээрх эсийн тооны гуравны хоёр дээр гаралтын давхрага дээрх эсийн тоог нэмсэтэй адил байх ёстой. ","","o Гаралтын давхрага дээрх эсийн тоо оролтын давхрага дээрх эсийн тоог хоёр дахин авсанаас бага байх ёстой. ","","- Эцэст нь нейроны сүлжээний туршилт болон алдаанаас хамаарч нууц давхрагууд дээрх эсийн тоо ихсэж, багасаж болно. Ер нь эсийн тоо болон нейроны сүлжээний оновчтой бүтцийг тодорхойлдог алгоритмууд байдаг. Үүнийг Прунинг нейроны сүлжээ гэж нэрлэдэг. ","","- Сургалтын жишээний тоо. Цөөхөн жишээтэй байхад сүлжээ сайн үр дүн өгдөггүй. Олон жишээтэй байх нь зорилгын функцэд илүү дөхсөн байна. сургалтын жишээний тоог нэмээд байхад сургалтын олонлогийн алдаа, шалгах олонлогийн алдаа хоёр ижил утга авч нэг цэгт нийлдэг. Тэр утга дахь жишээний тоо нь жишээний оновчтой тоо юм. ","","**Нейроны сүлжээг үгзүйд ашиглах нь** ","","Нейроны сүлжээ нь аналоги систем тул тоон утгууд хүлээн авч, боловсруулдаг. Иймээс текстийг нейроны сүлжээгээр боловсруулахын тулд тоо руу хөрвүүлэх шаардлагатай. Аналог систем нь 0-с 1 хүртэлх тоо байдаг. Иймээс нэг үсгийг 0 ба 1 тоонуудаас бүрдэх массиваар илэрхийлнэ. ","","Нейроны сүлжээний гол давуу тал бол тодорхой бодлогын жишээгээр сургаж, сурсан нейроны сүлжээг жишээнд ороогүй бодлого бодуулахад зөв бодож гаргах юм. иймээс үг зөв бичгийн дүрмээр хувилгах жишээнүүдээр сургаж байгаад жишээнд байхгүй үгийг хувилах байдлаар нейроны сүлжээг ашиглаж болно. Үгзүйн хувьд зөв бичгийн дүрмээр хувиргах, үгийг бүтцээр задлах гэсэн хоёр нейроны сүлжээ байна.",""]}]]},"ace":{"folds":[],"scrolltop":935,"scrollleft":0,"selection":{"start":{"row":87,"column":0},"end":{"row":87,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":65,"state":"allowBlock","mode":"ace/mode/markdown"}},"timestamp":1511241441672,"hash":"63f210451542efae4f230ff8ce1cade209a7fb53"}